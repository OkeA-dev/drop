## High -- [Issue 960 in Super DCA Liquidity Network on Sherlock](https://audits.sherlock.xyz/contests/1171/voting/960)

- **Description:**

    The `SuperDCAListing::collectFees()` function is designed to collect accumulated fees from `Uniswap V4` liquidity positions.  However this function fails to correctly handle pools that include native `ETH`. The current implementation exclusively uses the `IERC20` interface to check token balances, which is incompatible with native `ETH`.

    The core of the vulnerability lies in the direct casting of currency addresses to the `IERC20` interface within the `::collectFees()` function. `Uniswap V4` introduces direct support for native `ETH` in its liquidity pools. When a pool includes native `ETH`, the protocol represents it with the zero address `address(0)`.

    The `::collectFees()` function does not account for this distinction. It attempts to call `balanceOf()` on the currency address, assuming it is always a valid `ERC20` token contract. When the currency is native `ETH`, this results in a call to `IERC20(address(0)).balanceOf()`, which will either revert the transaction or fail
    to report the correct balance of `ETH` received.

- **Impact:**

    All fees denominated in native `ETH` that are generated by listed positions are uncollectible. Since `ETH`-paired pools are among the most popular and generate significant volume, this could represent a substantial loss of revenue for the protocol.

- **Recommended Mitigation:**

    Protocol specific.

## High -- [Issue 660 in Super DCA Liquidity Network on Sherlock](https://audits.sherlock.xyz/contests/1171/voting/660)

- **Description:**

    The logic of the `SuperDCAStaking::unstake()` has a faulty assumption; all rewards have been fully accounted for as at the moment of unstaking. However this is not guaranteed, thus leading to a critical race condition.

    When a user unstakes their tokens, the `::unstake()` function prematurely resets a crucial reward accounting checkpoint (`lastRewardIndex`). This action prematurely erases any pending rewards that have accrued for the entire token bucket since the last global reward calculation, leading to a direct and irrecoverable loss of funds for all stakers in that pool.

- **Impact:**

    Permanent loss of pending rewards for all affected users.

- **Recommended Mitigation:**

    Protocol specific.


## Medium -- [Issue S-703 in Megapot on Code4rena](https://code4rena.com/audits/2025-11-megapot/submissions/S-703)

- **Description:**

    `Jackpot::buyTickets()` allows users to purchase jackpot tickets for the current drawing. When a new drawing initializes via `Jackpot::_setNewDrawingState()`, critical parameters are copied from global state into the `DrawingState` struct.   

    `referralFee` however is not included in this struct. Since `referralFee` is not snapshotted in the `DrawingState` when a drawing initializes, `Jackpot::buyTickets()` reads it directly from global state.

    So, users purchase tickets, `Jackpot::_validateAndTrackReferrals()` calculates referral fees using the global `referralFee` -a value which can be updated during an active drawing by the admin when `Jackpot::setReferralFee()` is called. This means users buying tickets at different times contribute different amounts to `lpEarnings`, even though they pay the same `ticketPrice`.

 - **Impact:**

    - Users purchasing tickets at different times receive different economic treatment despite paying the same ticket price, competing for the same prize pool, and having identical winning probabilities.
    -  LP Pool Earnings becomes unpredictable as LPs cannot predict their returns when admin changes referralFee mid-drawing.

- **Recommended Mitigation:**

    The protocol can either add modifier to prevent admin from updating changes mid-drawing, or modify `DrawingState` struct to include `referralFee` and reflect these changes in the logic of `::_setNewDrawingState()`, `::_validateAndTrackReferrals()`, and `::buyTickets()` functions.

## Medium -- [Issue 690 in Super DCA Liquidity Network on Sherlock](https://audits.sherlock.xyz/contests/1171/voting/690)

- **Description:**

    A critical flaw in the initialization logic of the `SuperDCAStaking.sol` contract allows the first user to stake , to claim an enormous, unearned reward. The contract incorrectly calculates rewards for the entire "dead time" period between its deployment and the first stake, attributing this entire amount to the first staker.

- **Impact:**

    This bug allows for a massive, unjust transfer of value to a single user at the expense of the entire protocol and its community. The first staker is disproportionately rewarded in a way that is completely unrelated to their actual contribution.

- **Recommended Mitigation:**

    Protocol specific.

